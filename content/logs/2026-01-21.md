# 2026-01-21

_Generated at: 2026-01-21T04:07:43.063Z_

### State Management - Understanding useReducer for Complex State Logic

In React, managing component state can become complex, especially when the state logic involves multiple sub-values or when the next state depends on the previous one. The `useReducer` hook provides a powerful way to manage state in such scenarios.

### When to Use It
- **Complex State Logic**: When your component state is complex and consists of multiple related values, using `useReducer` can simplify the management of that state.
- **State Dependent on Previous State**: If the next state relies on the current state, `useReducer` helps avoid potential pitfalls of stale state that can arise with `useState`.

### Example
```jsx
import React, { useReducer } from 'react';

const initialState = { count: 0 };

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'decrement':
      return { count: state.count - 1 };
    case 'reset':
      return initialState;
    default:
      throw new Error();
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, initialState);

  return (
    <div>
      Count: {state.count}
      <button onClick={() => dispatch({ type: 'increment' })}>+</button>
      <button onClick={() => dispatch({ type: 'decrement' })}>-</button>
      <button onClick={() => dispatch({ type: 'reset' })}>Reset</button>
    </div>
  );
}

export default Counter;
```

### Explanation
- **Reducer Function**: The reducer function defines how the state changes in response to dispatched actions, making it easier to read and maintain.
- **Action Types**: Using action types makes it clear what each button does, which helps maintain the code and understand state transitions easily.

By leveraging `useReducer`, developers can handle more complex state logic within their React components efficiently.
